# 1장. 데이터 타입

> 자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써 기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하자

<details>
  <summary>목차</summary>
  <ul>
    <li><a href="#1-1-데이터-타입의-종류">1-1. 데이터 타입의 종류</a></li>
    <li><a href="#1-2-데이터-타입에-관한-배경지식">1-2. 데이터 타입에 관한 배경지식</a></li>
    <li><a href="#1-3-변수-선언과-데이터-할당">1-3. 변수 선언과 데이터 할당</a></li>
    <li><a href="#1-4-기본형-데이터와-참조형-데이터">1-4. 기본형 데이터와 참조형 데이터</a></li>
    <li><a href="#1-5-불변-객체">1-5. 불변 객체</a></li>
    <li><a href="#1-6-undefined와-null">1-6. undefined와 null</a></li>
    <li><a href="#1-7-정리">1-7. 정리</a></li>
  </ul>
</details>

<br />

## 1-1. 데이터 타입의 종류

자바스크립트의 데이터 타입은 크게 **기본형**과 **참조형** 두 가지로 나눌 수 있다.

<table>
<tr>
  <th>기본형(원시형. primitive type)</th>
  <th>참조형(reference type)</th>
</tr>
<tr>
  <td>할당이나 연산시 <b>값이 담긴 주솟값</b>을 바로 복제</td>
  <td>할당이나 연산시 <b>값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값</b>을 복제</td>
</tr>
<tr>
  <td>Number, String, Boolean, null, undefined, Symbol</td>
  <td>Object<br />- Array, Function, Date, RegExp, Map(WeakMap), Set(WeakSet)</td>
</tr>
</table>

기본형은 **불변성(immutability)** 을 띄는데 불변성을 이해하기 위해서는 메모리와 데이터에 대한 지식, 그리고 식별자와 변수의 개념을 구분할 수 있어야 한다.

<br />

## 1-2. 데이터 타입에 관한 배경지식

### 1. 메모리와 데이터

컴퓨터는 모든 데이터를 0 또는 1로 바꿔 기억한다. 0 또는 1만 표현할 수 있는 하나의 메모리 조각을 **비트(bit)** 라고 한다. 메모리는 매우 많은 비트들로 구성되어 있고, 각 비트는 **고유한 식별자(unique identifer)** 를 통해 위치를 확인할 수 있다.

비트 단위로 위치를 확인하는 것은 너무 작아 비효율적이기에, 8개의 비트를 묶어 **바이트(byte)** 단위를 사용한다. 1bit는 2개의 값(0, 1)을 표현하고 1byte는 256(2^8)개의 값을 표현할 수 있다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbhkvCw%2FbtsbQRFKj78%2FxyP7snCtinKt9CJPK3Xjhk%2Fimg.png" alt="비트와 바이트" width="300"> (출처: 모두를 위한 컴퓨터 과학 (CS50 2019))

<br />

앞서 비트는 고유한 식별자를 통해 위치를 확인할 수 있다 했다. 바이트 역시 시작하는 비트의 식별자로 위치를 파악할 수 있다.

즉, 모든 데이터는 바이트 단위의 식별자, 더 정확하게는 **메모리 주솟값(memory address)** 을 통해 서로 구분하고 연결할 수 있다.

<br />

### 2. 식별자와 변수

**변수(variable)** 는 **변할 수 있는 데이터**를 말하고,

**식별자(identifer)** 는 어떤 데이터를 식별하는 데 사용하는 이름, 즉 **변수명** 을 말한다.

보통 변수와 식별자를 혼용하는 경우가 많은데, 둘의 차이를 알고 문맥에 따라 무엇을 말하고자 하는지를 유추해야 한다.

<br />

## 1-3. 변수 선언과 데이터 할당

### 1. 변수 선언

```js
var a;
```

위 코드를 해석하자면

- 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇이 존재하고 (변수)
- 이 공간의 이름이 `a`이다. (식별자)

그리고 위를 메모리 영역의 변화로 표현하면 아래와 같다.

⛔️ 이미지 p5 1-3

코드 예제의 명령을 받은 컴퓨터는 메모리에서 비어있는 공간(1003)을 하나 확보(변수)한다. 이 공간의 이름(식별자)는 `a`이며 여기까지가 변수 선언 과정이다.

이후 사용자가 `a`에 접근하고자 하면 컴퓨터는 메모리에서 `a`라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환할 것이다.

<br />

### 2. 데이터 할당

```js
var a; // 변수 a 선언
a = "abc"; // 변수 a에 데이터 할당
```

```js
var a = "abc"; // 변수 선언과 할당을 한 문장으로 표현
```

**자바스크립트 엔진**은 변수 선언과 할당은 위처럼 2줄로 나눠 작성하든, 1줄로 작성하든, **상관없이 같은 동작을 수행**한다.

<br />

데이터 할당 과정은 `a`라는 이름을 가진 주소를 검색해서 그곳에 문자열 `abc`를 할당하면 될 것 같지만 실제로는 그렇지 않다. 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 `abc`를 저장, 그 주소를 변수 영역에 저장하는 식으로 이뤄진다.

<br />

데이터의 성질에 따라 **'변수 영역'**과 **'데이터 영역'**으로 구분해 설명해보자.

⛔️ 이미지 p7 1-4

1. 변수 영역에서 빈 공간(`@1003`)을 확보한다.
2. 확보한 공간의 식별자를 `a`로 지정한다.
3. 데이터 영역의 빈 공간(`@5004`)에 문자열 `abc`를 저장한다.
4. 변수 영역에서 `a`라는 식별자를 검색한다(`@1003`).
5. 앞서 저장한 문자열의 주소(`@5004`)를 `@1003`의 공간에 대입한다.

<br />

변수 영역에 값을 직접 대입하지 않고 위와 같은 번거로운 과정을 거치는 이유는 **데이터 변환을 자유롭게 할 수 있게 함**과 동시에 **메모리를 더육 효율적으로 관리**하기 위한 고민의 결과다.

자바스크립트의 숫자형 데이터는 64비트의 공간을 확보하지만 문자열은 특별히 정해진 규격이 없어 가변적이기 때문이다. 만약 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환 데이터를 다시 저장할 때 확보된 공간을 변환 데이터 크기에 맞게 늘리는 작업이 선행되어야 하는데 컴퓨터가 처리해야 할 연산이 많아지는 결과를 낳는다.

때문에 효율적으로 문자열 데이터 변환 처리를 위해 **변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적**이다.

<br />

```js
var a = "abc";
a = "abcdef"; // "abc" 뒤에 "def"를 추가 => 그래도 새로 할당
```

⛔️ 이미지 p8 1-5

문자열 "abc"와 "abcdef"만 보면 기존 문자열 맨뒤에 추가만 형태지만 문자열을 **새로** 만들었다고 이해해야한다. **무조건 새로 만들어 별도의 공간에 저장한다.**

<br />

## 1-4. 기본형 데이터와 참조형 데이터

### 1. 불변값

변수(variable)와 상수(constant)를 구분하는 성질은 **변경 가능성**이다. 바꿀 수 있으면 변수, 바꿀 수 없으면 **상수**다. 그렇다고 상수와 **불변값**을 같은 개념으로 오해해선 안된다. 명확히 구분할 필요가 있다.

변수/상수를 구분 짓는 변경 가능성의 대상은 **변수 영역** 메모리이다. 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이다.

반면 **불변성** 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역** 메모리이다.

<br />

예제1)

```js
var a = "abc";
a = a + "def";
```

변수 `a`에 문자열 "abc"를 할당했다가 뒤에 "def"를 추가했다. 그렇다고해서 기존의 "abc"가 "abcdef"로 바뀌는 것이 아니라 새로운 문자열 "abcdef"를 만들고 그 주소를 변수 `a`에 저장한다. "abc"와 "abcdef"는 완전 별개의 데이터다.

<br />

예제2)

```js
var b = 5;
var c = 5;
b = 7;
```

변수 `b`에 숫자 5를 할당하기 위해서 컴퓨터는 데이터 영역에서 5를 찾고, 없으면 데이터 공간을 하나 만들어 저장한다. 그리고 그 주소를 `b`에 저장한다. 변수 `c`는 이 주소를 재활용한다.

`b = 7`를 통해 변수 `b`의 값을 7로 바꾸기 위해 데이터 영역에서 다시 기존에 저장했던 7이 있는지 찾아 헤맨다. 있으면 그 주소를 재활용하고 없으면 새로 만들어 `b`에 저장한다.

<br />

이렇듯 **한 번 만든 값을 바꿀 수 없다.** 변경은 새로 만드는 동작을 통해서만 이뤄진다. 이것이 불변값의 성질이다. 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.

**기본형 데이터**인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값이다.

<br />

### 1-4-2. 가변값

기본형 데이터가 모두 불변값이라면 참조형 데이터는 모두 가변값일까? 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우가 있고, 아예 불변값으로 활용하는 방안도 있다. 불변값으로 활용하는 방안은..... 나중에

```js
var obj1 = {
  a: 1,
  b: "bbb",
};
```

<br />

### 1-4-3. 변수 복사 비교

## 1-5. 불변 객체

### 1-5-1. 불변 객체를 만드는 간단한 방법

### 1-5-2. 얕은 복사와 깊은 복사

<br />

## 1-6. undefined와 null

자바스크립트에서 '없음'을 나타내는 값은 **`undefined`** 와 **`null`** 두 가지가 있다. 두 값의 의미는 같은 것 같으면서도 차이가 있고, 사용하는 목적도 다르다.

<br />

**`undefined`** 는 사용자가 명시적으로 지정할 수도 있지만 **값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하는 경우**도 있다. 이 중 후자에 대해서 살펴보자.

자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 `undefined`를 반환한다. 아래 세 가지가 이에 해당된다.

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

```js
var a;
console.log(a); // ? undefined // 1. 값을 대입하지 않은 변수에 접근

var obj = { a: 1 };
console.log(obj.a); // ? 1
console.log(obj.b); // ? undefined // 2. 존재하지 않는 프로퍼티에 접근
console.log(b); // 예외) ReferenceError: b is not defined

var func = function () {};
var c = func(); // 3. 반환값이 없으면 undefined를 반환한 것으로 간주.
console.log(c); // ? undefined
```

그런데 이 중 1번. 값을 대입하지 않은 경우에 대해 배열의 경우는 조금 특이한 동작을 한다.

```js
// 케이스 (1)
var arr1 = [];
arr1.length = 3;
console.log(arr1); // ? [empty x 3]

/// 케이스 (2)
var arr2 = new Array(3);
console.log(arr2); // ? [empty x 3]

// 케이스 (3)
var arr3 = [undefined, undefined, undefined];
console.log(arr3); // ? [undefined, undefined, undefined]
```

위의 케이스 (1), (2)는 배열에 3개의 빈 요소를 확보했지만, 각 요소에는 어떠한 값도 할당돼 있지 않다. 직접적으로 undefined를 할당시킨 케이스 (3)와는 다르다. **'비어있는 요소'와 'undefined를 할당한 요소'는 서로 다름**을 보여준다.

전자는 배열 메서드의 순회 대상에서도 제외된다. 그 예제가 아래에 있다.

```js
var arr1 = [undefined, 1]; // 요소에 직접 undefined를 할당한 배열 arr1
var arr2 = []; // 비어있는 요소를 포함한 배열 arr2
arr2[1] = 1;

// forEach 메서드 : empty 요소 스킵
arr1.forEach((v, i) => {
  console.log(v, i);
}); // ? undefined 0 / 1 1
arr2.forEach((v, i) => {
  console.log(v, i);
}); // ? 1 1

// map 메서드 : empty는 empty
arr1.map((v, i) => {
  return v + i;
}); // ? [NaN, 2]
arr2.map((v, i) => {
  return v + i;
}); // ? [empty, 2]

// filter 메서드 : empty 요소 스킵
arr1.filter((v, i) => {
  return !v;
}); // ? [undefined]
arr2.filter((v, i) => {
  return !v;
}); // ? []

// reduce 메서드 : empty 요소 스킵
arr1.reduce((p, c, i) => {
  return p + c + i;
}, ""); // ? undefined011
arr2.reduce((p, c, i) => {
  return p + c + i;
}, ""); // ? 11
```

사실 배열에서만 발견할 수 있는 특별한 현상은 아니고 "배열도 객체"라는 점으로 생각하면 자연스러운 현상이다. 존재하지 않는 프로퍼티에 대해서는 순회할 수 없기 때문에 위같이 어떠한 처리를 하지 않고 건너뛰는 경우가 존재하는 것이다.

<br />

정리하자면

- **사용자가 명시적으로 undefined를 부여한 경우**는 undefined 그 자체로 **값**이다. 프로퍼티나 배열의 요소는 고유한 키값(프로퍼티 이름)이 실존하게 되고, 순회의 대상이 된다.
- 한편, **비어있는 요소에 접근하려 할 때 반환되는 undefined**(자바스크립트 엔진이 하는 수 없이 반환해주는 undefined)는 **값이 없음**을 나타낸다. 해당 프로퍼티 내지 배열의 키값(인덱스) 자체가 존재하지 않는다.

<br />

undefined의 위 혼란을 피하기 위한 가장 좋은 방법은 직접 undefined를 할당하지 않는 것이다. **"비어있음"을 명시적으로 표현하기 위해서는 `null`을 사용하자.**

null을 사용할 때 주의점은 변수의 값이 null인지 판별하기 위한 방식으로 `typeof`를 채택할 수 없다는 점이다. 대신에 **일치 연산자(===)** 를 사용한다.

```js
var n = null;

// typeof X
console.log(typeof n); // ? object

// 동등 연산자(==) X
console.log(n == undefined); // ? true
console.log(n == null); // ? true

// 일치 연산자(===) O
console.log(n === undefined); // ? false
console.log(n === null); // ? true
```

<br />

## 1-7. 정리

자바스크립트 데이터 타입

- 기본형 : 불변값
- 참조형 : 가변값

<br />

변수와 식별자

- 변수 : 변경 가능한 데이터가 담길 수 있는 공간
- 식별자 : 그 변수의 이름

<br />

변수 선언 동작

1. 컴퓨터가 우선 메모리의 빈 공간에 식별자를 저장
2. 해당 공간에 자동으로 undefined 할당

변수 할당 동작

1. 별도의 공간에 데이터를 저장
2. 그 공간의 주소를 변수의 값 영역에 할당

<br />

참조형 데이터를 할당하는 과정

1. 컴퓨터는 참조형 데이터 내부 프로퍼티들을 위한 변수 영역을 확보
2. 확보된 주소를 변수에 연결
3. 앞서 확보한 변수 영역에 각 프로퍼티의 식별자를 저장
4. 각 데이터를 별도의 공간에 저장해서 그 주소를 식별자들과 매칭

<br />

기본형과 참조형이 할당 과정에서 차이가 생긴 이유

- 참조형 데이터가 여러개의 프로퍼티(변수)를 모은 '그룹'이기 때문
- 이 차이로 인해 참조형 데이터를 '가변값'으로 여겨야만 하는 상황이 발생한다.

<br />

참조형 데이터를 가변값으로 여겨야 하는 상황임에도 불변값으로 사용하는 방법

- 내부 프로퍼티들을 일일이 복사하기 (깊은 복사)
- 라이브러리 사용

<br />

'없음'을 나타내는 값

- undefined : 어떤 변수에 값이 존재하지 않는 경우
- null : 사용자가 명시적으로 '없음'을 표현하기 위해 대입한 값
