# 1장. 데이터 타입

> 자바스크립트가 데이터를 처리하는 과정을 살펴봄으로써 기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하자

<details>
  <summary>목차</summary>
  <ul>
    <li><a href="#1-1-데이터-타입의-종류">1-1. 데이터 타입의 종류</a></li>
    <li><a href="#1-2-데이터-타입에-관한-배경지식">1-2. 데이터 타입에 관한 배경지식</a></li>
    <li><a href="#1-3-변수-선언과-데이터-할당">1-3. 변수 선언과 데이터 할당</a></li>
    <li><a href="#1-4-기본형-데이터와-참조형-데이터">1-4. 기본형 데이터와 참조형 데이터</a></li>
    <li><a href="#1-5-불변-객체">1-5. 불변 객체</a></li>
    <li><a href="#1-6-undefined와-null">1-6. undefined와 null</a></li>
  </ul>
</details>

<br />

## 1-1. 데이터 타입의 종류

자바스크립트의 데이터 타입은 크게 **기본형**과 **참조형** 두 가지로 나눌 수 있다.

<table>
<tr>
  <th>기본형(원시형. primitive type)</th>
  <th>참조형(reference type)</th>
</tr>
<tr>
  <td>할당이나 연산시 <b>값이 담긴 주솟값</b>을 바로 복제</td>
  <td>할당이나 연산시 <b>값이 담긴 주소값들로 이루어진 묶음을 가리키는 주소값</b>을 복제</td>
</tr>
<tr>
  <td>Number, String, Boolean, null, undefined, Symbol</td>
  <td>Object<br />- Array, Function, Date, RegExp, Map(WeakMap), Set(WeakSet)</td>
</tr>
</table>

기본형은 **불변성(immutability)** 을 띄는데 불변성을 이해하기 위해서는 메모리와 데이터에 대한 지식, 그리고 식별자와 변수의 개념을 구분할 수 있어야 한다.

<br />

> 💡 **자바스크립트 데이터 타입**
>
> - 기본형 : 불변값
> - 참조형 : 가변값

<br />

## 1-2. 데이터 타입에 관한 배경지식

### 1. 메모리와 데이터

컴퓨터는 모든 데이터를 0 또는 1로 바꿔 기억한다. 0 또는 1만 표현할 수 있는 하나의 메모리 조각을 **비트(bit)** 라고 한다. 메모리는 매우 많은 비트들로 구성되어 있고, 각 비트는 **고유한 식별자(unique identifer)** 를 통해 위치를 확인할 수 있다.

비트 단위로 위치를 확인하는 것은 너무 작아 비효율적이기에, 8개의 비트를 묶어 **바이트(byte)** 단위를 사용한다. 1bit는 2개의 값(0, 1)을 표현하고 1byte는 256(2^8)개의 값을 표현할 수 있다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbhkvCw%2FbtsbQRFKj78%2FxyP7snCtinKt9CJPK3Xjhk%2Fimg.png" alt="비트와 바이트" width="300"> (출처: 모두를 위한 컴퓨터 과학 (CS50 2019))

<br />

앞서 비트는 고유한 식별자를 통해 위치를 확인할 수 있다 했다. 바이트 역시 시작하는 비트의 식별자로 위치를 파악할 수 있다.

즉, 모든 데이터는 바이트 단위의 식별자, 더 정확하게는 **메모리 주솟값(memory address)** 을 통해 서로 구분하고 연결할 수 있다.

<br />

### 2. 식별자와 변수

**변수(variable)** 는 **변할 수 있는 데이터**를 말하고, **식별자(identifer)** 는 어떤 데이터를 식별하는 데 사용하는 이름, 즉 **변수명** 을 말한다.

보통 변수와 식별자를 혼용하는 경우가 많은데, 둘의 차이를 알고 문맥에 따라 무엇을 말하고자 하는지를 유추해야 한다.

<br />

> 💡 **변수와 식별자**
>
> - 변수 : 변경 가능한 데이터가 담길 수 있는 공간
> - 식별자 : 그 변수의 이름

<br />

## 1-3. 변수 선언과 데이터 할당

### 1. 변수 선언

```js
var a;
```

위 코드를 해석하자면

- 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇이 존재하고 (변수)
- 이 공간의 이름이 `a`이다. (식별자)

그리고 위를 메모리 영역의 변화로 표현하면 아래와 같다.

<img src="https://github.com/Coding-Village-Protector/core-js/assets/26590099/d2ec3d46-3af1-4cd3-9e0a-e59c1a179268" alt="변수 선언에 대한 메모리 영역의 변화">(출처: 코어 자바스크립트)

코드 예제의 명령을 받은 컴퓨터는 메모리에서 비어있는 공간(1003)을 하나 확보(변수)한다. 이 공간의 이름(식별자)는 `a`이며 여기까지가 변수 선언 과정이다.

이후 사용자가 `a`에 접근하고자 하면 컴퓨터는 메모리에서 `a`라는 이름을 가진 주소를 검색해 해당 공간에 담긴 데이터를 반환할 것이다.

<br />

### 2. 데이터 할당

```js
var a; // 변수 a 선언
a = "abc"; // 변수 a에 데이터 할당
```

```js
var a = "abc"; // 변수 선언과 할당을 한 문장으로 표현
```

**자바스크립트 엔진**은 변수 선언과 할당은 위처럼 2줄로 나눠 작성하든, 1줄로 작성하든, **상관없이 같은 동작을 수행**한다.

<br />

데이터 할당 과정은 `a`라는 이름을 가진 주소를 검색해서 그곳에 문자열 `abc`를 할당하면 될 것 같지만 실제로는 그렇지 않다. 데이터를 저장하기 위한 별도의 메모리 공간을 다시 확보해서 문자열 `abc`를 저장, 그 주소를 변수 영역에 저장하는 식으로 이뤄진다.

<br />

데이터의 성질에 따라 **변수 영역**과 **데이터 영역**으로 구분해 설명할 수 있다.

<img src="https://github.com/Coding-Village-Protector/core-js/assets/26590099/1c04071c-07f5-4e19-a5d5-29070958c100" alt="데이터 할당에 대한 메모리 영역의 변화">(출처: 코어 자바스크립트)

1. 변수 영역에서 빈 공간(`@1003`)을 확보한다.
2. 확보한 공간의 식별자를 `a`로 지정한다.
3. 데이터 영역의 빈 공간(`@5004`)에 문자열 `abc`를 저장한다.
4. 변수 영역에서 `a`라는 식별자를 검색한다(`@1003`).
5. 앞서 저장한 문자열의 주소(`@5004`)를 `@1003`의 공간에 대입한다.

<br />

변수 영역에 값을 직접 대입하지 않고 위와 같은 번거로운 과정을 거치는 이유는 **데이터 변환을 자유롭게 할 수 있게 함**과 동시에 **메모리를 더욱 효율적으로 관리**하기 위한 고민의 결과다.

자바스크립트의 숫자형 데이터는 64비트의 공간을 확보하지만 문자열은 특별히 정해진 규격이 없어 가변적이기 때문이다. 만약 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환 데이터를 다시 저장할 때 확보된 공간을 변환 데이터 크기에 맞게 늘리는 작업이 선행되어야 하는데 컴퓨터가 처리해야 할 연산이 많아지는 결과를 낳는다.

때문에 효율적으로 문자열 데이터 변환 처리를 위해 **변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적**이다.

<br />

```js
var a = "abc";
a = "abcdef"; // "abc" 뒤에 "def"를 추가 => 그래도 새로 할당
```

<img src="https://github.com/Coding-Village-Protector/core-js/assets/26590099/d56f95dc-3530-4dd4-b9d0-b49e505d3798" alt="문자열 변환에 대한 메모리 영역의 변화">(출처: 코어 자바스크립트)

문자열 "abc"와 "abcdef"만 보면 기존 문자열 맨뒤에 추가만 형태지만 문자열을 **새로** 만들었다고 이해해야한다. **무조건 새로 만들어 별도의 공간에 저장한다.**

<br />

> 💡 **변수 선언 동작**
>
> 1. 컴퓨터가 우선 메모리의 빈 공간에 식별자를 저장
> 2. 해당 공간에 자동으로 undefined 할당
>
> 💡 **변수 할당 동작**
>
> 1. 별도의 공간에 데이터를 저장
> 2. 그 공간의 주소를 변수의 값 영역에 할당

<br />

## 1-4. 기본형 데이터와 참조형 데이터

### 1. 불변값

변수(variable)와 상수(constant)를 구분하는 성질은 **변경 가능성**이다. 바꿀 수 있으면 변수, 바꿀 수 없으면 **상수**다. 그렇다고 상수와 **불변값**을 같은 개념으로 오해해선 안된다. 명확히 구분할 필요가 있다.

변수/상수를 구분 짓는 변경 가능성의 대상은 **변수 영역** 메모리이다. 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건이다.

반면 **불변성** 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역** 메모리이다.

<br />

예제 1)

```js
var a = "abc";
a = a + "def";
```

변수 `a`에 문자열 "abc"를 할당했다가 뒤에 "def"를 추가했다. 그렇다고해서 기존의 "abc"가 "abcdef"로 바뀌는 것이 아니라 새로운 문자열 "abcdef"를 만들고 그 주소를 변수 `a`에 저장한다. "abc"와 "abcdef"는 완전 별개의 데이터다.

<br />

예제 2)

```js
var b = 5;
var c = 5;
b = 7;
```

변수 `b`에 숫자 5를 할당하기 위해서 컴퓨터는 데이터 영역에서 5를 찾고, 없으면 데이터 공간을 하나 만들어 저장한다. 그리고 그 주소를 `b`에 저장한다. 변수 `c`는 이 주소를 재활용한다.

`b = 7`를 통해 변수 `b`의 값을 7로 바꾸기 위해 데이터 영역에서 다시 기존에 저장했던 7이 있는지 찾아 헤맨다. 있으면 그 주소를 재활용하고 없으면 새로 만들어 `b`에 저장한다.

<br />

이렇듯 **한 번 만든 값을 바꿀 수 없다.** 변경은 새로 만드는 동작을 통해서만 이뤄진다. 이것이 불변값의 성질이다. 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.

**기본형 데이터**인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값이다.

<br />

### 2. 가변값

기본형 데이터가 모두 불변값이라면 참조형 데이터는 모두 가변값일까? 기본적인 성질은 가변값인 경우가 많지만 설정에 따라 변경 불가능한 경우도 있고(`Object.defineProperty` 등), 아예 불변값으로 활용하는 방안도 있다.

불변값을 활용하는 방안은 뒤에서 소개하고, 우선 **참조형 데이터를 변수에 할당하는 과정**부터 확인해보자.

<br />

🔎 **참조형 데이터의 프로퍼티 할당**

```js
var obj1 = {
  a: 1,
  b: "bbb",
};
```

<img src="https://github.com/Coding-Village-Protector/core-js/assets/26590099/59885dcd-6db5-4c19-9252-188be9cfdc99" alt="참조형 데이터의 할당">(출처: 코어 자바스크립트)

1. 컴퓨터는 우선 변수 영역의 빈 공간(`@1002`)을 확보하고, 그 주소의 이름을 `obj1`로 지정한다.
2. 임의의 데이터 저장 공간(`@5001`)에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다. 이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련하고, 그 영역의 주소(`@7103 ~ ?`)를 `@5001`에 저장한다.
3. `@7103` 및 `@7104`에 각각 `a`와 `b`라는 프로퍼티 이름을 지정한다.
4. 데이터 영역에서 숫자 1을 검색한다. 검색 결과가 없으므로 임의로 `@5003`에 저장하고 이 주소를 `@7103`에 저장한다. 문자열 "bbb" 역시 임의로 `@5004`에 저장하고 이 주소를 `@7104`에 저장한다.

<br />

기본형 데이터와의 차이는 **객체의 변수(프로퍼티) 영역**이 별도로 존재한다는 점이다. 그림으로 보다시피 데이터 영역은 기존의 메모리 공간을 그대로 활용한다.

데이터 영역에 저장된 값은 모두 불변값이다. 하지만 변수에는 다른 값을 얼마든지 대입할 수 있다.

바로 이 부분 때문에 **흔히 참조형 데이터는 불변(immutable)하지 않다(=가변값이다)** 라고 한다.

<br />

🔎 참조형 데이터의 프로퍼티 **재할당**

```js
obj1.a = 2; // obj1의 a 프로퍼티에 숫자 2 할당 (기존: 숫자 1)
```

<img src="https://github.com/Coding-Village-Protector/core-js/assets/26590099/50b851d1-226b-4001-b812-680c92796642" alt="참조형 데이터의 할당">(출처: 코어 자바스크립트)

데이터 영역에서 숫자 2를 검색. 검색결과가 없기 때문에 빈 공간인 `@5005`에 숫자 2를 저장하고, 이 주소를 `@7103`에 저장한다.

변수 `obj1`이 바라보고 있는 주소는 `@5001`로 동일하다. **새로운 객체가 만들어진 것이 아니다.**

<br />

🔎 참조형 데이터의 프로퍼티에 **참조형 데이터를 할당** (**중첩 객체**. nested object)

```js
var obj = {
  x: 3,
  arr: [3, 4, 5], // 중첩 객체
};
```

<img src="https://github.com/Coding-Village-Protector/core-js/assets/26590099/73158166-cb59-4d52-aca5-4b2b683115ab" alt="중첩된 참조형 데이터(객체)의 프로퍼티 할당">(출처: 코어 자바스크립트)

1. 참조형 데이터의 프로퍼티 할당 과정의 1-4번과 동일. `@7104`에 이름 `arr`를 지정한다.
2. `@7104`에 저장할 값 역시 데이터 그룹이다. 이 그룹 내부의 프로퍼티를 저장하기 위해 별도의 변수 영역을 마련하고(`@8104 ~ ?`), 그 영역의 주소 정보(`@8104 ~ ?`)를 `@5003`에 저장한다. 그리고 `@5003`을 `@7104`에 저장한다.
3. 배열의 요소 크기 3만큼 변수 공간을 확보하고 각가의 인덱스를 부여한다.
4. 데이터 영역에서 숫자 3을 검색해서(`@5002`) 그 주소를 `@8104`에 저장한다.
5. 데이터 영역에서 숫자 4가 없으므로 (`@5004`)에 저장하고, 이 주소를 `@8105`에 저장한다.
6. 데이터 영역에서 숫자 5가 없으므로 (`@5005`)에 저장하고, 이 주소를 `@8106`에 저장한다.

이렇게 된 상황에서 만일 `obj.arr[1]`을 검색하고자 하면 메모리에서 이뤄지는 주소 이동 과정은 다음과 같다.
`@1002` -> `@5001` -> (@7103 ~ ?) -> `@7104` -> `@5003` -> (@8104 ~ ?) -> `@8105` -> `@5004` -> 4 반환

<br />

🔎 **중첩된 참조형 데이터**의 프로퍼티 **재할당**

여기에서 기존에 중첩 객체였던 `obj.arr`에 기본형 데이터인 문자열을 재할당하면 **가비지 컬렉터**가 활성화된다.

```js
obj.arr = "str"; // obj의 arr 프로퍼티에 문자열 "str" 할당 (기존: 배열 [3, 4, 5])
```

<img src="https://github.com/Coding-Village-Protector/core-js/assets/26590099/62938904-60b3-45b4-9134-20858ff6285a" alt="중첩된 참조형 데이터(객체)의 프로퍼티 재할당">(출처: 코어 자바스크립트)

문자열 "str"을 저장하기 위해 변수 영역의 임의의 빈 공간(`@5006`) 확보. 그 주소는 `@7104`에 저장한다. 그리고 `@5003`은 자신의 주소를 참조하는 변수의 개수(참조 카운트)가 0이 된다. 이어서 `@5003`에 담겨져 있던 데이터인 `@8104 ~ ?`라는 값도 사라지고, 연쇄적으로 `@8104`, `@8105`, `@8106`도 참조 카운트가 0이 된다.

**참조 카운트가 0인 메모리 주소**는 **가비지 컬렉터**(garbage collector, **GC**)의 수거 대상이 된다. 가비지 컬렉터는 런타임 환경에 따라 특정 시점이나 메모리 사용량이 포화 상태에 임박할 때마다 자동으로 수거 대상들을 수거(collecting)한다. 수거된 메모리는 다시 새로운 값을 할당할 수 있는 빈 공간이 된다.

즉, `@5003`, `@8104`, `@8105`, `@8106`는 모두 GC의 대상이 되어 사라질 예정이다.

<br />

### 3. 변수 복사 비교

🔎 **기본형 데이터**의 변수 복사 vs **참조형 데이터**의 변수 복사

```js
var a = 10; // 기본형 데이터
var b = a; // 변수 복사
```

```js
var obj1 = { c: 10, d: "ddd" }; // 참조형 데이터
var obj2 = obj1; // 변수 복사
```

<img src="https://github.com/Coding-Village-Protector/core-js/assets/26590099/27457dc9-489f-43a8-92c4-8ffef6328c33" alt="변수 복사 비교">

기본형 데이터 `a`를 복사한 `b`의 과정을 살펴보면 빈 공간 `@1002`를 확보하고 식별자를 `b`로 지정한다. 그리고 데이터 영역 내 숫자 10이 있는 주소를 저장해야 하는데, `@1001`에 저장된 `@5001`이 그에 해당한다.

참조형 데이터 `obj1`를 복사한 `obj2`의 과정을 살펴보면 빈 공간 `@1004`를 확보하고 식별자를 `obj2`로 지정한다. 그리고 식별자 `obj1`을 검색해(`@1003`) 그 값인 `@5002`를 들고, `@1004`에 값으로 대입한다.

보다시피 **변수를 복사하는 과정은 기본형/참조형 모두 같은 주소를 바라보게 된다는 점에서 동일**하다. 다만, 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있기 때문에 **변수 복사 이후의 동작에도 큰 차이가 발생**한다.

<br />

🔎 **변수 복사 이후 값 변경 결과 비교** (1) - 객체의 프로퍼티 변경 시

```js
var a = 10; // 기본형 데이터
var b = a; // 변수 복사
b = 15; // 값 변경
```

```js
var obj1 = { c: 10, d: "ddd" }; // 참조형 데이터
var obj2 = obj1; // 변수 복사
obj2.c = 20; // 객체의 프로퍼티 변경

console.log(obj1, obj2); // ? { c: 20, d: 'ddd' } { c: 20, d: 'ddd' }
```

<img src="https://github.com/Coding-Village-Protector/core-js/assets/26590099/81873c8e-efe2-46eb-9309-1a34c0fdbdd6" alt="변수 복사 이후 값을 변경했을 때의 차이점 (1) - 객체의 프로퍼티를 변경했을 때">

기본형 데이터를 복사한 변수 `b`의 값을 바꾸는 경우는 `@1002`의 값이 달라진 반면, 참조형 데이터를 복사한 변수 `obj2`의 프로퍼티의 값을 바꾸는 것은 `@1004`의 값이 달라지지 않는다. 즉, 변수 `a`, `b`는 서로 다른 주소를 바라보게 됐지만(`a !== b`), 변수 `obj1`, `obj2`는 여전히 같은 객체를 바라보고 있다.(`obj1 === obj2`)

이 결과가 **기본형/참조형 데이터의 가장 큰 차이점**이다. **기본형 데이터는 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다**는 차이가 있다. (설명의 어려움으로 인해 일반적으로 기본형이 주솟값을 참조한다는 사실을 소개하지 않는다.)

<br />

🔎 **변수 복사 이후 값 변경 결과 비교** (2) - 객체 자체 변경 시

앞서 `b`와 같이 `obj2`의 내부 프로퍼티(`c`)의 값을 변경하는 것이 아닌 **객체 자체를 직접 변경**하는 경우도 비교하면 다음과 같다.

```js
var obj1 = { c: 10, d: "ddd" }; // 참조형 데이터
var obj2 = obj1; // 변수 복사
obj2 = { c: 20, d: "ddd" }; // 객체 자체를 변경

console.log(obj1, obj2); // ? { c: 10, d: 'ddd' } { c: 20, d: 'ddd' }
```

<img src="https://github.com/Coding-Village-Protector/core-js/assets/26590099/9eb43771-9318-4e78-9d99-73f10358b385" alt="변수 복사 이후 값을 변경했을 때의 차이점 (2) - 객체 자체를 변경했을 때">

이렇게 변경하니 객체에 대한 변경임에도 값이 달라진다.

즉, **참조형 데이터가 가변값**이라고 설명할 때의 가변은 **참조형 데이터 내부의 프로퍼티를 변경할 때만 성립**한다.

<br />

> 💡 **참조형 데이터를 할당하는 과정**
>
> 1. 컴퓨터는 참조형 데이터 내부 프로퍼티들을 위한 변수 영역을 확보
> 2. 확보된 주소를 변수에 연결
> 3. 앞서 확보한 변수 영역에 각 프로퍼티의 식별자를 저장
> 4. 각 데이터를 별도의 공간에 저장해서 그 주소를 식별자들과 매칭
>
> 💡 **기본형과 참조형이 할당 과정에서 차이가 생긴 이유**
>
> - 참조형 데이터가 여러개의 프로퍼티(변수)를 모은 '그룹'이기 때문
> - 이 차이로 인해 참조형 데이터를 '가변값'으로 여겨야만 하는 상황이 발생한다.

<br />

## 1-5. 불변 객체

### 1. 불변 객체를 만드는 간단한 방법

참조형 데이터의 가변은 위에서 정리햇듯이 데이터 자체가 아닌 내부 프로퍼티를 변경할 때만 성립한다. 데이터 자체를 변경하고자 하면(새로운 데이터를 할당하고자 하면) 기본형 데이터와 마찬가지로 **기존 데이터는 변하지 않는다.**

그렇다면 내부 프로퍼티를 변경할 필요가 있을 때마다 매번 새로운 객체를 만들어 재할당하기로 규칙을 정하거나 자동으로 새로운 객체를 만드는 도구(ex. immutable.js)를 활용한다면 **객체 또한 불변성을 확보할 수 있을 것이다.** 이를 **불변 객체(immutable object)** 라고 칭한다.

<br />

🔎 **객체의 가변성에 따른 문제점**

값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우에 불변 객체가 필요하다.

아래는 코드는 객체의 가변성으로 인해 `user`와 `user2`가 같은 객체를 바라보고 있는 상황이다.

```js
var user = {
  name: "Jaenam",
  gender: "male",
};

var changeName = function (user, newName) {
  var newUser = user;
  newUser.name = newName;
  return newUser;
}; // 프로퍼티(name)만 수정 : 가변값의 조건 => changeName 함수를 거치기 전과 후가 같은 객체를 바라보게 됨

var user2 = changeName(user, "Jung");

if (user !== user2) {
  console.log("유저 정보가 변경되었습니다.");
}
console.log(user.name, user2.name); // ? Jung Jung
console.log(user === user2); // ? true
```

`user`와 `user2`가 서로 다른 객체를 바라보게 만들기 위한 방법으로는 `changeName` 함수가 **새로운 객체를 반환**하도록 하는 것이 있다.

```js
var user = {
  name: "Jaenam",
  gender: "male",
};

var changeName = function (user, newName) {
  return {
    name: newName,
    gender: user.gender,
  }; // 프로퍼티만 변경하는 것이 아닌 아예 새로운 객체를 반환 : 불변성을 가짐 => changeName 함수를 거치기 전과 후가 다른 객체를 바라보게 됨
};

var user2 = changeName(user, "Jung");

if (user !== user2) {
  console.log("유저 정보가 변경되었습니다."); // ? 유저 정보가 변경되었습니다.
}
console.log(user.name, user2.name); // ? Jaenam Jung
console.log(user === user2); // ? false
```

<br />

### 2. 얕은 복사와 깊은 복사

**얕은 복사(shallow copy)** 는 **바로 아래 단계의 값만 복사**하는 방법이다.

만일 중첩된 객체에서 얕은 복사를 한다는 것은 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사한다는 의미이다. 그러면 해당 프로퍼티에 대해 원본과 사본이 모두 동일한 참조형 데이터 주소를 가리키게 된다. **사본과 원본이 서로의 변경에 영향을 받는다.**

그러니까 어떤 객체를 복사할 때 **완전히 새로운 데이터**를 만들고자 할 때, 기본형 데이터인 경우에는 그대로 복사해도 문제되지 않는다. 하지만 **참조형 데이터**인 경우는 **다시 그 내부의 프로퍼티들을 복사**해야만 하고 이 과정을 **깊은 복사**라고 말한다.

**깊은 복사(deep copy)** 는 **내부의 모든 값들을 하나하나 찾아서 전부 복사**하는 방법이다.

<br />

예시 1) 중첩된 객체에 대한 얕은 복사 적용

```js
var copyObject = function (target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop]; // 👈 얕은 복사 방식 (예시 3과 관련)
  }
  return result;
};

var user = {
  urls: {
    portfolio: "http://github.com/abc",
    blog: "http://blog.com",
    facebook: "http://facebook.com/abc",
  },
};

var user2 = copyObject(user); // 👈 얕은 복사 방식 (예시 2와 관련)
user.urls.portfolio = "http://portfolio.com";
console.log(user.urls.portfolio === user2.urls.portfolio); // ? true

user2.urls.blog = "";
console.log(user.urls.blog === user2.urls.blog); // ? true
```

예시 2) 중첩된 객체에 대한 깊은 복사 적용 (1) - 내부 프로퍼티 직접 복사

```js
var user2 = copyObject(user); // 👈 얕은 복사 방식
user2.urls = copyObject(user.urls); // 👈 위를 보완하여 내부 프로퍼티 `urls`에 결과를 직접 할당 추가 : 깊은 복사 적용

user.urls.portfolio = "http://portfolio.com";
console.log(user.urls.portfolio === user2.urls.portfolio); // ? false

user2.urls.blog = "";
console.log(user.urls.blog === user2.urls.blog); // ? false
```

예시 3) 중첩된 객체에 대한 깊은 복사 적용 (2) - 함수가 깊은 복사를 수행

```js
// before) 얕은 복사 함수 copyObject
var copyObject = function (target) {
  var result = {};
  for (var prop in target) {
    result[prop] = target[prop];
  }
  return result;
};

// after) 깊은 복사 함수 copyObjectDeep
var copyObjectDeep = function (target) {
  var result = {};
  if (typeof target === "object" && target !== null) {
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]); // 👈 내부 프로퍼티들을 순회하며 재귀적으로 호출
    }
  } else {
    result = target;
  } // 원본과 사본이 서로 완전히 다른 객체를 참조하도록 만들어 어느쪽의 프로퍼티를 변경하더라도 다른 쪽에 영향을 주지 않게 함
  return result;
};

var user2 = copyObjectDeep(user); // 👈 copyObjectDeep 함수 적용

user.urls.portfolio = "http://portfolio.com";
console.log(user.urls.portfolio === user2.urls.portfolio); // ? false

user2.urls.blog = "";
console.log(user.urls.blog === user2.urls.blog); // ? false
```

<br />

> 💡 **참조형 데이터를 가변값으로 여겨야 하는 상황임에도 불변값으로 사용하는 방법**
>
> - 내부 프로퍼티들을 일일이 복사하기 (깊은 복사)
> - 라이브러리 사용

<br />

## 1-6. undefined와 null

자바스크립트에서 '없음'을 나타내는 값은 **`undefined`** 와 **`null`** 두 가지가 있다. 두 값의 의미는 같은 것 같으면서도 차이가 있고, 사용하는 목적도 다르다.

<br />

**`undefined`** 는 사용자가 명시적으로 지정할 수도 있지만 **값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하는 경우**도 있다. 이 중 후자에 대해서 살펴보자.

자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 `undefined`를 반환한다. 아래 세 가지가 이에 해당된다.

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

```js
var a;
console.log(a); // ? undefined // 1. 값을 대입하지 않은 변수에 접근

var obj = { a: 1 };
console.log(obj.a); // ? 1
console.log(obj.b); // ? undefined // 2. 존재하지 않는 프로퍼티에 접근
console.log(b); // 예외) ReferenceError: b is not defined

var func = function () {};
var c = func(); // 3. 반환값이 없으면 undefined를 반환한 것으로 간주.
console.log(c); // ? undefined
```

그런데 이 중 1번. 값을 대입하지 않은 경우에 대해 배열의 경우는 조금 특이한 동작을 한다.

```js
// 케이스 (1)
var arr1 = [];
arr1.length = 3;
console.log(arr1); // ? [empty x 3]

/// 케이스 (2)
var arr2 = new Array(3);
console.log(arr2); // ? [empty x 3]

// 케이스 (3)
var arr3 = [undefined, undefined, undefined];
console.log(arr3); // ? [undefined, undefined, undefined]
```

위의 케이스 (1), (2)는 배열에 3개의 빈 요소를 확보했지만, 각 요소에는 어떠한 값도 할당돼 있지 않다. 직접적으로 undefined를 할당시킨 케이스 (3)와는 다르다. **'비어있는 요소'와 'undefined를 할당한 요소'는 서로 다름**을 보여준다.

전자는 배열 메서드의 순회 대상에서도 제외된다. 그 예제가 아래에 있다.

```js
var arr1 = [undefined, 1]; // 요소에 직접 undefined를 할당한 배열 arr1
var arr2 = []; // 비어있는 요소를 포함한 배열 arr2
arr2[1] = 1;

// forEach 메서드 : empty 요소 스킵
arr1.forEach((v, i) => {
  console.log(v, i);
}); // ? undefined 0 / 1 1
arr2.forEach((v, i) => {
  console.log(v, i);
}); // ? 1 1

// map 메서드 : empty는 empty
arr1.map((v, i) => {
  return v + i;
}); // ? [NaN, 2]
arr2.map((v, i) => {
  return v + i;
}); // ? [empty, 2]

// filter 메서드 : empty 요소 스킵
arr1.filter((v, i) => {
  return !v;
}); // ? [undefined]
arr2.filter((v, i) => {
  return !v;
}); // ? []

// reduce 메서드 : empty 요소 스킵
arr1.reduce((p, c, i) => {
  return p + c + i;
}, ""); // ? undefined011
arr2.reduce((p, c, i) => {
  return p + c + i;
}, ""); // ? 11
```

사실 배열에서만 발견할 수 있는 특별한 현상은 아니고 "배열도 객체"라는 점으로 생각하면 자연스러운 현상이다. 존재하지 않는 프로퍼티에 대해서는 순회할 수 없기 때문에 위같이 어떠한 처리를 하지 않고 건너뛰는 경우가 존재하는 것이다.

<br />

정리하자면

- **사용자가 명시적으로 undefined를 부여한 경우**는 undefined 그 자체로 **값**이다. 프로퍼티나 배열의 요소는 고유한 키값(프로퍼티 이름)이 실존하게 되고, 순회의 대상이 된다.
- 한편, **비어있는 요소에 접근하려 할 때 반환되는 undefined**(자바스크립트 엔진이 하는 수 없이 반환해주는 undefined)는 **값이 없음**을 나타낸다. 해당 프로퍼티 내지 배열의 키값(인덱스) 자체가 존재하지 않는다.

<br />

undefined의 위 혼란을 피하기 위한 가장 좋은 방법은 직접 undefined를 할당하지 않는 것이다. **"비어있음"을 명시적으로 표현하기 위해서는 `null`을 사용하자.**

null을 사용할 때 주의점은 변수의 값이 null인지 판별하기 위한 방식으로 `typeof`를 채택할 수 없다는 점이다. 대신에 **일치 연산자(===)** 를 사용한다.

```js
var n = null;

// typeof X
console.log(typeof n); // ? object

// 동등 연산자(==) X
console.log(n == undefined); // ? true
console.log(n == null); // ? true

// 일치 연산자(===) O
console.log(n === undefined); // ? false
console.log(n === null); // ? true
```

<br />

> 💡 **'없음'을 나타내는 값**
>
> - undefined : 어떤 변수에 값이 존재하지 않는 경우
> - null : 사용자가 명시적으로 '없음'을 표현하기 위해 대입한 값
